"use client"

import jsPDF from 'jspdf'
import html2canvas from 'html2canvas'

interface Slide {
  id: string
  type: string
  title: string
  content: string
  suggestedImages?: string[]
  speakerNotes?: string
  mediaUrls?: string[]
  mediaDescriptions?: string[]
}

export async function exportToPDF(slides: Slide[], deckTitle: string, deckDescription?: string) {
  try {
    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'pt',
      format: 'a4'
    })

    const pageWidth = pdf.internal.pageSize.getWidth()
    const pageHeight = pdf.internal.pageSize.getHeight()
    const margin = 40
    const contentWidth = pageWidth - 2 * margin
    const contentHeight = pageHeight - 2 * margin

    // Title page
    pdf.setFontSize(24)
    pdf.setFont('helvetica', 'bold')
    pdf.text(deckTitle, pageWidth / 2, 100, { align: 'center' })
    
    if (deckDescription) {
      pdf.setFontSize(14)
      pdf.setFont('helvetica', 'normal')
      const descLines = pdf.splitTextToSize(deckDescription, contentWidth)
      pdf.text(descLines, pageWidth / 2, 140, { align: 'center' })
    }

    pdf.setFontSize(12)
    pdf.text(`Generated on ${new Date().toLocaleDateString()}`, pageWidth / 2, pageHeight - 60, { align: 'center' })

    // Add slides
    for (let i = 0; i < slides.length; i++) {
      const slide = slides[i]
      pdf.addPage()
      
      // Slide number
      pdf.setFontSize(10)
      pdf.setFont('helvetica', 'normal')
      pdf.text(`${i + 1} / ${slides.length}`, pageWidth - margin, 30, { align: 'right' })
      
      // Slide title
      pdf.setFontSize(20)
      pdf.setFont('helvetica', 'bold')
      pdf.text(slide.title, margin, 80)
      
      // Slide content
      pdf.setFontSize(12)
      pdf.setFont('helvetica', 'normal')
      
      // Process content to handle bullet points
      const processedContent = slide.content
        .replace(/•/g, '• ')
        .replace(/\n\n/g, '\n')
      
      const contentLines = pdf.splitTextToSize(processedContent, contentWidth)
      let yPosition = 120
      
      for (const line of contentLines) {
        if (yPosition > pageHeight - margin - 60) {
          pdf.addPage()
          yPosition = 80
          
          // Repeat slide title on continuation page
          pdf.setFontSize(16)
          pdf.setFont('helvetica', 'bold')
          pdf.text(`${slide.title} (continued)`, margin, 40)
          pdf.setFontSize(12)
          pdf.setFont('helvetica', 'normal')
        }
        
        pdf.text(line, margin, yPosition)
        yPosition += 16
      }
      
      // Add suggested images section
      if (slide.suggestedImages && slide.suggestedImages.length > 0) {
        yPosition += 20
        if (yPosition > pageHeight - margin - 100) {
          pdf.addPage()
          yPosition = 80
        }
        
        pdf.setFontSize(14)
        pdf.setFont('helvetica', 'bold')
        pdf.text('Suggested Images:', margin, yPosition)
        yPosition += 20
        
        pdf.setFontSize(10)
        pdf.setFont('helvetica', 'normal')
        for (const image of slide.suggestedImages) {
          if (yPosition > pageHeight - margin - 40) {
            pdf.addPage()
            yPosition = 80
          }
          pdf.text(`• ${image}`, margin + 20, yPosition)
          yPosition += 14
        }
      }
      
      // Add speaker notes
      if (slide.speakerNotes) {
        yPosition += 20
        if (yPosition > pageHeight - margin - 100) {
          pdf.addPage()
          yPosition = 80
        }
        
        pdf.setFontSize(14)
        pdf.setFont('helvetica', 'bold')
        pdf.text('Speaker Notes:', margin, yPosition)
        yPosition += 20
        
        pdf.setFontSize(10)
        pdf.setFont('helvetica', 'italic')
        const notesLines = pdf.splitTextToSize(slide.speakerNotes, contentWidth)
        for (const line of notesLines) {
          if (yPosition > pageHeight - margin - 40) {
            pdf.addPage()
            yPosition = 80
          }
          pdf.text(line, margin, yPosition)
          yPosition += 12
        }
      }
    }

    // Save the PDF
    const fileName = `${deckTitle.replace(/[^a-zA-Z0-9]/g, '_')}_pitch_deck.pdf`
    pdf.save(fileName)
    
    return { success: true, fileName }
  } catch (error) {
    console.error('PDF export error:', error)
    throw new Error('Failed to export PDF')
  }
}

export async function exportToPPTX(slides: Slide[], deckTitle: string, deckDescription?: string) {
  try {
    // Dynamic import for PptxGenJS (works better with SSR)
    const PptxGenJS = (await import('pptxgenjs')).default
    
    const pptx = new PptxGenJS()
    
    // Set presentation properties
    pptx.author = 'PitchDeck AI'
    pptx.company = 'Generated by PitchDeck AI'
    pptx.title = deckTitle
    pptx.subject = deckDescription || 'AI-Generated Pitch Deck'
    
    // Define slide layout
    pptx.defineLayout({ name: 'LAYOUT_16x9', width: 10, height: 5.625 })
    pptx.layout = 'LAYOUT_16x9'
    
    // Title slide
    const titleSlide = pptx.addSlide()
    titleSlide.addText(deckTitle, {
      x: 1,
      y: 1.5,
      w: 8,
      h: 1.5,
      fontSize: 32,
      bold: true,
      align: 'center',
      color: '363636'
    })
    
    if (deckDescription) {
      titleSlide.addText(deckDescription, {
        x: 1,
        y: 3,
        w: 8,
        h: 1,
        fontSize: 16,
        align: 'center',
        color: '666666'
      })
    }
    
    titleSlide.addText(`Generated on ${new Date().toLocaleDateString()}`, {
      x: 1,
      y: 4.5,
      w: 8,
      h: 0.5,
      fontSize: 12,
      align: 'center',
      color: '999999'
    })
    
    // Add content slides
    for (let i = 0; i < slides.length; i++) {
      const slide = slides[i]
      const pptxSlide = pptx.addSlide()
      
      // Slide number
      pptxSlide.addText(`${i + 1} / ${slides.length}`, {
        x: 8.5,
        y: 0.2,
        w: 1.5,
        h: 0.3,
        fontSize: 10,
        align: 'right',
        color: '999999'
      })
      
      // Slide title
      pptxSlide.addText(slide.title, {
        x: 0.5,
        y: 0.5,
        w: 9,
        h: 0.8,
        fontSize: 24,
        bold: true,
        color: '363636'
      })
      
      // Slide content
      const processedContent = slide.content
        .replace(/•/g, '• ')
        .split('\n')
        .filter(line => line.trim())
        .slice(0, 12) // Limit to prevent overflow
      
      let yPos = 1.5
      const lineHeight = 0.25
      
      for (const line of processedContent) {
        if (yPos > 4.5) break // Prevent overflow
        
        pptxSlide.addText(line.trim(), {
          x: 0.5,
          y: yPos,
          w: 9,
          h: lineHeight,
          fontSize: 14,
          color: '444444',
          lineSpacing: 20
        })
        yPos += lineHeight
      }
      
      // Add suggested images as text (since we can't embed actual images easily)
      if (slide.suggestedImages && slide.suggestedImages.length > 0 && yPos < 4.5) {
        pptxSlide.addText('Suggested Images:', {
          x: 0.5,
          y: yPos + 0.2,
          w: 9,
          h: 0.3,
          fontSize: 12,
          bold: true,
          color: '666666'
        })
        
        const imageText = slide.suggestedImages.slice(0, 3).map(img => `• ${img}`).join('\n')
        pptxSlide.addText(imageText, {
          x: 0.5,
          y: yPos + 0.5,
          w: 9,
          h: 0.8,
          fontSize: 10,
          color: '777777'
        })
      }
    }
    
    // Add notes slide if there are speaker notes
    const slidesWithNotes = slides.filter(s => s.speakerNotes)
    if (slidesWithNotes.length > 0) {
      const notesSlide = pptx.addSlide()
      notesSlide.addText('Speaker Notes', {
        x: 0.5,
        y: 0.5,
        w: 9,
        h: 0.8,
        fontSize: 24,
        bold: true,
        color: '363636'
      })
      
      let yPos = 1.5
      for (const slide of slidesWithNotes) {
        if (yPos > 4.5) break
        
        notesSlide.addText(`${slide.title}:`, {
          x: 0.5,
          y: yPos,
          w: 9,
          h: 0.3,
          fontSize: 14,
          bold: true,
          color: '444444'
        })
        
        const notesText = slide.speakerNotes!.substring(0, 200) + (slide.speakerNotes!.length > 200 ? '...' : '')
        notesSlide.addText(notesText, {
          x: 0.5,
          y: yPos + 0.3,
          w: 9,
          h: 0.5,
          fontSize: 12,
          color: '666666'
        })
        
        yPos += 0.9
      }
    }
    
    // Save the PPTX
    const fileName = `${deckTitle.replace(/[^a-zA-Z0-9]/g, '_')}_pitch_deck.pptx`
    await pptx.writeFile({ fileName })
    
    return { success: true, fileName }
  } catch (error) {
    console.error('PPTX export error:', error)
    throw new Error('Failed to export PPTX')
  }
}